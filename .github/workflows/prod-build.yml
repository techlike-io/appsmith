name: Prod CI

# 1
# Controls when the workflow will run
on:
  release:
    types:
      # Unlike the `released` event, the `published` event triggers for pre-releases as well.
      - released

  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:
    inputs:
      version:
        description: "Image version"
        required: true
#2
env:
  IMAGE_NAME: appsmith-ce

jobs:
  prelude:
    runs-on: ubuntu-latest

    outputs:
      tag: ${{ steps.get_version.outputs.tag }}
      is_beta: ${{ steps.get_version.outputs.is_beta }}

    steps:
      - name: Environment details
        run: |
          echo "PWD: $PWD"
          echo "GITHUB_REF: $GITHUB_REF"
          echo "GITHUB_SHA: $GITHUB_SHA"
          echo "GITHUB_EVENT_NAME: $GITHUB_EVENT_NAME"

      - name: Get the version
        id: get_version
        run: |
          tag="$(date +%s)"
          echo "tag=$tag" >> $GITHUB_OUTPUT
          if [[ $tag == *"beta"* ]]; then
            echo "is_beta=true" >> $GITHUB_OUTPUT
          else
            echo "is_beta=false" >> $GITHUB_OUTPUT
          fi

  client-build:
    needs:
      - prelude

    runs-on: ubuntu-latest

    defaults:
      run:
        working-directory: app/client
        shell: bash

    steps:
      # Checkout the code
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Use Node.js 16.14.0
        uses: actions/setup-node@v3
        with:
          node-version: "16.14.0"

      # Retrieve npm dependencies from cache. After a successful run, these dependencies are cached again
      - name: Cache npm dependencies
        uses: actions/cache@v3
        env:
          cache-name: cache-yarn-dependencies
        with:
          # npm dependencies are stored in `~/.m2` on Linux/macOS
          path: ~/.npm
          key: ${{ runner.OS }}-node-${{ hashFiles('**/yarn.lock') }}
          restore-keys: |
            ${{ runner.OS }}-node-
            ${{ runner.OS }}-

      - name: Install dependencies
        run: yarn install --frozen-lockfile

      - name: Create the bundle
        env:
          REACT_APP_ENVIRONMENT: "PRODUCTION"
          CI: "" # Disable warnings as errors
          REACT_APP_FUSIONCHARTS_LICENSE_KEY: "${{ secrets.APPSMITH_FUSIONCHARTS_LICENSE_KEY }}"
          REACT_APP_SEGMENT_CE_KEY: "${{ secrets.APPSMITH_SEGMENT_CE_KEY }}"
          REACT_APP_VERSION_ID: "${{ needs.prelude.outputs.tag }}"
          REACT_APP_INTERCOM_APP_ID: "${{ secrets.APPSMITH_INTERCOM_ID }}"
          REACT_APP_VERSION_EDITION: "Community"
        run: |
          REACT_APP_VERSION_RELEASE_DATE="$(date -u '+%Y-%m-%dT%H:%M:%SZ')" \
            yarn build
          ls -l build

      # Upload the build artifact so that it can be used by the test & deploy job in the workflow
      - name: Upload react build bundle
        uses: actions/upload-artifact@v3
        with:
          name: client-build
          path: app/client/build/

  server-build:
    needs:
      - prelude

    defaults:
      run:
        working-directory: app/server

    runs-on: ubuntu-latest

    steps:
      - name: Checkout the code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Set up JDK 17
        uses: actions/setup-java@v3
        with:
          distribution: 'temurin'
          java-version: '17'

      # Retrieve maven dependencies from cache. After a successful run, these dependencies are cached again
      - name: Cache maven dependencies
        uses: actions/cache@v3
        env:
          cache-name: cache-maven-dependencies
        with:
          # maven dependencies are stored in `~/.m2` on Linux/macOS
          path: ~/.m2
          key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}
          restore-keys: ${{ runner.os }}-m2

      - name: Test and Build package
        working-directory: app/server
        run: |
          mvn --batch-mode versions:set \
            -DnewVersion=${{ needs.prelude.outputs.tag }} \
            -DgenerateBackupPoms=false \
            -DprocessAllModules=true
          ./build.sh -DskipTests
          ls -l dist

      - name: Upload server build bundle
        uses: actions/upload-artifact@v3
        with:
          name: server-build
          path: app/server/dist/

  rts-build:
    needs:
      - prelude

    defaults:
      run:
        working-directory: app/rts

    runs-on: ubuntu-latest

    steps:
      # Checkout the code
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Use Node.js 16.14.0
        uses: actions/setup-node@v3
        with:
          node-version: "16.14.0"

      - name: Build
        run: |
          echo 'export const VERSION = "${{ needs.prelude.outputs.tag }}"' > src/version.js
          yarn build

      # Tar the bundles to speed up the upload & download process
      - name: Tar the rts bundles
        run: |
          ls -al dist/node_modules/@shared/ast
          tar -cvf rts-dist.tar dist

      # Upload the build artifacts and dependencies so that it can be used by the test & deploy job in other workflows
      - name: Upload rts build bundle
        uses: actions/upload-artifact@v3
        with:
          name: rts-dist
          path: app/rts/rts-dist.tar

  package:
    needs: [prelude, client-build, server-build, rts-build]

    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write

    steps:
      - name: Checkout the merged commit
        uses: actions/checkout@v3

      - name: Download the client build artifact
        uses: actions/download-artifact@v3
        with:
          name: client-build
          path: app/client/build

      - name: Download the server build artifact
        uses: actions/download-artifact@v3
        with:
          name: server-build
          path: app/server/dist

      - name: Download the rts build artifact
        uses: actions/download-artifact@v3
        with:
          name: rts-dist
          path: app/rts/dist

      - name: Untar the rts folder
        run: |
          tar -xvf app/rts/dist/rts-dist.tar -C app/rts/
          echo "Cleaning up the tar files"
          rm app/rts/dist/rts-dist.tar

      - name: Build container image
        run: docker build -t $(echo ${{ secrets.REGISTRY }})/$(echo $IMAGE_NAME):prod --build-arg APPSMITH_SEGMENT_CE_KEY=${{ secrets.APPSMITH_SEGMENT_CE_KEY }} .

      - name: Install doctl
        uses: digitalocean/action-doctl@v2
        with:
          token: ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}

      - name: Log in to DigitalOcean Container Registry with short-lived credentials
        run: doctl registry login --expiry-seconds 600

      - name: Remove all old images
        run: if [ ! -z "$(doctl registry repository list | grep "$(echo $IMAGE_NAME)")" ]; then doctl registry repository delete-manifest $(echo $IMAGE_NAME) $(doctl registry repository list-tags $(echo $IMAGE_NAME) | grep -w '^prod' | grep -o "sha.*") --force; else echo "No repository"; fi

      - name: Push image to DigitalOcean Container Registry as prod image
        run: docker push $(echo ${{ secrets.REGISTRY }})/$(echo $IMAGE_NAME):prod

      - name: Configure kubectl to point to the prod instance
        run: doctl kubernetes cluster kubeconfig save ${{ secrets.PROD_CLUSTER_ID }}

      - name: Deploy the new image to the prod namespace
        run: kubectl rollout restart statefulset ${{ secrets.PROD_HELM_RELEASE_NAME }} --namespace ${{ secrets.PROD_HELM_RELEASE_NAMESPACE }}
